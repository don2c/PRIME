from __future__ import annotations

import argparse
import json
import math
from pathlib import Path

import pandas as pd


def fmt_float(x: float, nd: int = 2) -> str:
    if x is None:
        return "--"
    try:
        if math.isnan(float(x)) or math.isinf(float(x)):
            return "--"
    except Exception:
        return "--"
    return f"{float(x):.{nd}f}"


def fmt_int(x) -> str:
    if x is None:
        return "--"
    try:
        if isinstance(x, float) and (math.isnan(x) or math.isinf(x)):
            return "--"
        return str(int(round(float(x))))
    except Exception:
        return "--"


def pct(x: float, nd: int = 1) -> str:
    if x is None:
        return "--"
    try:
        if math.isnan(float(x)) or math.isinf(float(x)):
            return "--"
    except Exception:
        return "--"
    return f"{100.0 * float(x):.{nd}f}"


def dataset_label(ds: str) -> str:
    return {
        "osn_twitter": "OSN-Twitter",
        "osn_facebook": "OSN-Facebook",
        "ehealth": "E-health",
    }.get(ds, ds)


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--summary-csv", type=Path, required=True)
    ap.add_argument("--metadata-json", type=Path, required=True)
    ap.add_argument("--out-tex", type=Path, required=True)
    ap.add_argument("--label", type=str, default="tab:shape")
    ap.add_argument("--caption", type=str, default="")
    args = ap.parse_args()

    summ = pd.read_csv(args.summary_csv)
    meta = json.loads(args.metadata_json.read_text())

    plan = meta.get("plan", {})
    runs = meta.get("runs", "--")

    L = plan.get("L_bytes", "--")
    Theta = plan.get("Theta_ms", "--")
    dL = plan.get("delta_L", "--")
    dT = plan.get("delta_Theta_ms", "--")

    if args.caption.strip():
        caption = args.caption.strip()
    else:
        caption = (
            "Constant-shape enforcement and side-channel suppression. "
            f"Fixed envelope $L={L}$ bytes and $\\Theta={Theta}$ ms with tolerances "
            f"$\\delta_L={dL}$ bytes and $\\delta_\\Theta={dT}$ ms. "
            f"Reported means are over accepted runs ({runs} runs per dataset/churn setting). "
            "$\\Delta\\theta = |\\theta_S - \\Theta|$."
        )

    lines = []
    lines.append("% Auto-generated by prime_ring_shape.render_latex")
    lines.append("\\begin{table}[t]")
    lines.append("\\centering")
    lines.append(f"\\caption{{{caption}}}")
    lines.append(f"\\label{{{args.label}}}")
    lines.append("\\small")
    lines.append("\\setlength{\\tabcolsep}{5pt}")
    lines.append("\\begin{tabular}{llrrrr}")
    lines.append("\\toprule")
    lines.append("Dataset & Churn & $\\bar b$ (B) & $\\overline{\\Delta\\theta}$ (ms) & Reject (\\%) & Pool/Len/Time (\\%)\\\\")
    lines.append("\\midrule")

    # stable ordering
    summ = summ.sort_values(["dataset", "churn"]).reset_index(drop=True)

    for _, r in summ.iterrows():
        ds = dataset_label(str(r["dataset"]))
        churn = fmt_float(r["churn"], 2)
        b = fmt_float(r.get("mean_pad_bytes"), 1)
        drift = fmt_float(r.get("mean_drift_ms"), 3)
        rej = pct(r.get("reject_rate"), 1)
        pool = pct(r.get("reject_pool"), 1)
        rlen = pct(r.get("reject_length"), 1)
        rtime = pct(r.get("reject_time"), 1)
        breakdown = f"{pool}/{rlen}/{rtime}"
        lines.append(f"{ds} & {churn} & {b} & {drift} & {rej} & {breakdown}\\\\")

    lines.append("\\bottomrule")
    lines.append("\\end{tabular}")
    lines.append("\\end{table}")

    args.out_tex.parent.mkdir(parents=True, exist_ok=True)
    args.out_tex.write_text("\n".join(lines) + "\n")


if __name__ == "__main__":
    main()
